[Task 1.](TASK_DESCRIPTION.md)
=====

Активировать при необходимости виртуальное окружение:

```bash
python3 -m venv venv
```

Сгенерировать log файлы:

```bash
python3 log_generator.py <path/to/dir>
```

Например:

```bash
python3 log_generator.py ./data/
```

Объединить log файлы в один:
```bash
python3 <your_script>.py <path/to/log1> <path/to/log2> -o <path/to/merged/log>
```

Например, на основе предварительно сгенерированных файлов:
```bash
python3 merge_logfile.py data/log_a.jsonl data/log_b.jsonl -o data/out.jsonl
```

[Task 2.](TASK_DESCRIPTION.md)
======

**1.** Создаем новую таблицу для хранения имен - Names.

**2.** Добавляем в таблицу данных Data новую колонку name_id для хранения идентификатора имени 
(заполнив поле name_id значениями NULL).

**3.** По очереди останавливаем каждый сервис типа A, после чего для каждого сервиса:
   * Обновляем логику сервисов A так, чтобы сервис А заполнял и поле name в таблице данных, и name_id относительно таблицы имён;
   * При генерации новой записи если такого имени нет в таблице имён Names, сервис A должен добавлять новое имя в таблицу имён Names, генерируя новый name_id и добавляя его в таблицу Names. При этом важно, чтобы каждый сервис добавлял новые записи либо в транзакции с уровнем изоляции SERIALIZABLE, либо же блокировки таблицы LOCK TABLE. Это необходимо для того, чтобы в случае если другой сервис A также захочет добавить это же имя, то это сможет сделать это только один сервис;
   * Запускаем сервис А;

**4.** Таким образом, теперь все сервисы типа A будут производить данные не с пустым значением name_id. При этом, у нас всё ещё могут остаться некоторые пустые name_id. Для этого необходимо отдельно пройтись по таблице Data и все NULL значения в поле name_id заполнить относительно таблицы Names:
   * Если такое значение есть в таблице Names, то просто заполняем его;
   * Если нет, то снова либо под уровнем изоляции SERIALIZABLE_READ, либо используя LOCK TABLE, генерируем его и вписываем в таблицу Names;

Теперь во всех записях таблицы Data есть name_id, и все новые записи так же создаются с ним. Также, можем сделать поле name_id not null.

**5.** Следующим шагом по очереди останавливаем сервисы типа B, делая следующее:
   * Переводим их на реализацию с использованием поля name_id;
   * После чего запускаем;

**6.** Вновь по очереди останавливаем каждый сервисы типа A:
   * Прекращаем заполнение поля name в таблице Data;
   * Запускаем;

**7.** Удаляем старую колонку name из таблицы Data.